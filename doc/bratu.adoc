= Bratu's problem
:icons: font
:stem: latexmath

== Nonlinear equation

Consider the Bratu's problem

[stem]
++++
\begin{cases}
- \nabla \cdot (\nabla u ) + \lambda e^{u} = 0 \text{ in } \Omega \quad (1)
\\
u = 0 \text{ on } \partial \Omega
\end{cases}

++++

=== Continue

Multiply (1) by stem:[v] chosen so that it satisfies the same
boundary conditions as the trial solution stem:[u] and integrate on stem:[\Omega]

[stem]
++++
\displaystyle\int_{\Omega} - \nabla \cdot (\nabla u ) v + \int_{\Omega} \lambda e^{u} v = 0 \quad
\forall v \in H^1_0(\Omega)

++++

By using the formula of Green, we obtain

[stem]
++++
\displaystyle\int_{\Omega}  \nabla u \nabla v - \int_{\partial \Omega} (\nabla u \cdot n ) v + \int_{\Omega} \lambda e^{u} v = 0 \quad
\forall v \in H^1_0(\Omega)

++++

Hence from that stem:[v] is null on the boundary, we have the variational formulation

[stem]
.The variational problem
++++
\text{Determine u } \in H^1_0(\Omega) \text{ satisfying}
\\
\displaystyle\int_{\Omega} \nabla u \nabla v + \int_{\Omega} \lambda e^{u} v = 0 \quad \forall v \in H^1_0(\Omega)
++++

=== Discrete

Conformal approximation:

We use the Galerkin approximation method:

Let stem:[\{ \mathcal{T}_h \}] a family of meshes of stem:[\Omega].

Let stem:[\{ \mathcal{K}, P, \sum \}] a finite Lagrange element of degree stem:[k \geq 1].

Let stem:[P^k_{c,h}] the approximate space associated to the finite element stem:[\mathbb{P}_k] defined by

[stem]
++++
P^k_{ c,h} = \{ v \in C^0(\Omega), \forall \mathcal{K} \in \mathcal{T}_h, v|_{\mathcal{K}} \in \mathbb{P}_k(\mathcal{K}) \}

++++

To obtain a conformal approximation, we add the boundary conditions

[stem]
++++
V_h = P^k_{c,h} \cap H^1_0(\Omega)

++++


The problem variable approximation is therefore

[stem]
.Discreet problem
++++
\text{Determine u_h } \in V_h \text{ satisfying}
\\
A(u_h, v_h) = \displaystyle\int_{\Omega_h} \nabla u_h \nabla v_h + \int_{\Omega_h} \lambda e^{u_h} v_h = 0 \quad \forall v_h \in V_h

++++

=== Algebraic:

Let stem:[\{ \varphi_1, \varphi_2, ..., \varphi_N \}] a base of stem:[V_h]. An element stem:[u_h \in V_h] is written as

[stem]
++++
u_h = \sum^{N}_{i=1} u_i \varphi_i
++++

By using stem:[v] as the functions base of stem:[V_h], the problem variable approximation is equivalent to the system

[stem]
.Algebraic problem
++++
\text{Determine } u_i \text{ satisfying}
\\
A(\varphi_i, \varphi_j) = \displaystyle\int_{\Omega_h} \sum_{i=1}^N u_i \nabla \varphi_i \nabla \varphi_j
+ \int_{\Omega_h} \lambda e^{\sum_{i=1}^N u_i \varphi_i} \varphi_j = 0 \quad \forall j = 1, \cdots, N

++++

=== Apply Newton-Raphson's method

We can rewrite algebraic problem in the form of system

[stem]
++++
\begin{cases}
A_1(u_1, \cdots , u_N) = \displaystyle\int_{\Omega_h} \sum_{i=1}^N u_i \nabla \varphi_i \nabla \varphi_1
+ \int_{\Omega_h} \lambda e^{\sum_{i=1}^N u_i \varphi_i} \varphi_1 = 0
\\
A_2(u_1, \cdots , u_N) = \displaystyle\int_{\Omega_h} \sum_{i=1}^N u_i \nabla \varphi_i \nabla \varphi_2
+ \int_{\Omega_h} \lambda e^{\sum_{i=1}^N u_i \varphi_i} \varphi_2 = 0
\\
\vdots
\\
A_N(u_1, \cdots , u_N) = \displaystyle\int_{\Omega_h} \sum_{i=1}^N u_i \nabla \varphi_i \nabla\varphi_N
+ \int_{\Omega_h} \lambda e^{\sum_{i=1}^N u_i \varphi_i} \varphi_N = 0
\end{cases}

++++

Calculate the Jacobian

[stem]
++++
J =
\begin{bmatrix}
\frac{\partial A_1}{\partial u_1} & \frac{\partial A_1}{\partial u_2} & \cdots & \frac{\partial A_1}{\partial u_N}
\\
\frac{\partial A_2}{\partial u_1} & \frac{\partial A_2}{\partial u_2} & \cdots & \frac{\partial A_2}{\partial u_N}
\\
\vdots & \vdots & \ddots & \vdots
\\
\frac{\partial A_N}{\partial u_1} & \frac{\partial A_N}{\partial u_2} & \cdots & \frac{\partial A_N}{\partial u_N}

\end{bmatrix}

++++

Consider stem:[u^{(k)} = (u_1^{(k)}, \cdots , u_N^{(k)})] is the vector of stem:[u_h] in k-th iteration.
We evaluate

[stem]
++++
J(u^{(k)}) = \{ J_{lj} (u^{(k)}) \}_{lj = 1, \cdots, N}
\\
\text{where}
\\
J_{lj} (u^{(k)}) = \frac{\partial A_l}{\partial u_j} (u^{(k)}) =
\displaystyle\int_{\Omega_h} \nabla \varphi_l \nabla \varphi_j
+ \int_{\Omega_h} \lambda \varphi_l e^{\sum_{i=1}^N u_i \varphi_i} \varphi_j

++++

We determine the k-th residua

[stem]
++++
R^{(k)} =
\begin{bmatrix}
A_1(u^{(k)})
\\
A_2(u^{(k)})
\\
\vdots
\\
A_N(u^{(k)})
\end{bmatrix}
++++

and

[stem]
++++
\delta u^{(k)} = u^{(k+1)} - u^{(k)}
++++

We start with a  good estimate stem:[u^{(0)} \in V_h] (initial guess), then
calculate the new estimate stem:[u^{(1)}] by solving the system of linear equation

[stem]
++++
J(u^{(0)}) \delta u^{(0)} = - R^{(0)}
++++

and then determine

[stem]
++++
u^{(1)} = \delta u^{(0)} + u^{(0)}
++++

and so on, in k-th iteration, we find stem:[\delta u^{(k)}] by solving

[stem]
++++
J(u^{(k)}) \delta u^{(k)} = - R^{(k)}
++++

then determine the better estimate

[stem]
++++
u^{(k+1)} = \delta u^{(k)} + u^{(k)}
++++

[NOTE]: à completer

=== Implementation

The Jacobian's matrix

[source, cpp]
----
auto Jacobian = [=](const vector_ptrtype& X, sparse_matrix_ptrtype& J)
        {
            if (!J) J = backend()->newMatrix( Vh, Vh );
            auto a = form2( _test=Vh, _trial=Vh, _matrix=J );
            a = integrate( elements( mesh ), gradt( u )*trans( grad( v ) ) );
            a += integrate( elements( mesh ), lambda*( exp( idv( u ) ) )*idt( u )*id( v ) );
----

The residual

[source, cpp]
----
auto Residual = [=](const vector_ptrtype& X, vector_ptrtype& R)
        {
            auto u = Vh->element();
            u = *X;
            auto r = form1( _test=Vh, _vector=R );
            r = integrate( elements( mesh ), gradv( u )*trans( grad( v ) ) );
            r += integrate( elements( mesh ),  lambda*exp( idv( u ) )*id( v ) );
            //r += integrate(_range=markedfaces(mesh,"Dirichlet"), _expr=cst(0.) );
            r +=  integrate( boundaryfaces( mesh ),
                             ( - trans( id( v ) )*( gradv( u )*N() )
                               - trans( idv( u ) )*( grad( v )*N() )
                               + penalbc*trans( idv( u ) )*id( v )/hFace() ) );
        };

----

Solveur

[source, cpp]
----
u.zero();
    backend()->nlSolver()->residual = Residual;
    backend()->nlSolver()->jacobian = Jacobian;
    backend()->nlSolve( _solution=u );
----

To execute on 4 processors

----
mpirun -np 4 feelpp_doc_bratu --snes-monitor=true
----

The option `--snes-monitor=true` displays the Newton iteration residual.
To visualize the results type paraview `bratu-4.sos`.

=== Implement fort boundary condition of Dirichlet

Traitement des conditions aux limits sous forme forte c'est à dire on impose
fortement les valeurs de la fonction aux sommets (aux degrées liberté) du maillage
où il y a des conditions de Dirichlet.

On résoud à chaque itération le system linéaire avec stem:[u^{(k)}] connu

[stem]
++++
J(u^{(k)}) \delta u^{(k)} = - R^{(k)}
++++

et on calcule

[stem]
++++
u^{(k+1)} = \delta u^{(k)} - u^{(k)}
++++

Si des itérations de stem:[u^{(k)}] satisfait des conditions de Dirichlet, le terme
stem:[\delta u^{(k)}] doit s'annuler aux bord de Dirichlet.

Donc comment implémenter les conditions aux limits forte?

L'operateur `on` permet de rajouter le valeur de la fonction du condtion au limit
de Dirichlet.

On rajoute dans le Jacobian

[source, cpp]
----
a +=on(_range=markedfaces(mesh,"Dirichlet"), _element=u, _rhs = l, _expr = cst(0.) );
----

On a besoin alors de mettre le second membre

[source, cpp]
----
l = form1(X_h)
----

Comme stem:[u^{(k+1)}] doit satisfaire aussi la condition aux limits, il faut donner
l'initiale stem:[u^{(0)}]

[source, cpp]
----
a.on(_range=elements( mesh ), expr = cst(0.) );
----

IL reste un dernier point, ici on a modifié le système linéair
